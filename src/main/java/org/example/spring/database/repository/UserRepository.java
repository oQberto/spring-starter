package org.example.spring.database.repository;

import org.example.spring.database.entity.User;
import org.example.spring.database.entity.enums.Role;
import org.example.spring.dto.PersonalInfo;
import org.example.spring.dto.PersonalInfoInterface;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.EntityGraph;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * {@code @Repository} - это аннотация в Spring Framework, которая используется для пометки класса как репозитория (хранилища)
 * данных. Репозитории являются частью архитектуры доступа к данным (Data Access Layer) и предоставляют способ
 * взаимодействия с базой данных или другими источниками данных. Классы, помеченные @Repository, обычно используются
 * для выполнения операций чтения и записи данных в базе данных.
 * <p>
 * Основные характеристики и использование аннотации @Repository:
 * <p>
 * Обнаружение бинов: Классы, помеченные аннотацией @Repository, автоматически обнаруживаются Spring и регистрируются
 * как Spring бины в контексте приложения. Это позволяет использовать их для взаимодействия с данными, выполняя
 * операции базы данных.
 * <p>
 * Исключение обработки: Классы, помеченные @Repository, обычно используются для доступа к данным и могут автоматически
 * обрабатывать исключения, связанные с доступом к данным, и преобразовывать их в Spring исключения
 * (например, DataAccessException), что упрощает обработку ошибок доступа к данным.
 * <p>
 * Интеграция с Spring Data: @Repository часто используется в сочетании с Spring Data, что позволяет создавать
 * репозитории с помощью интерфейсов и автоматически создавать реализацию этих репозиториев Spring Data.
 */
public interface UserRepository extends JpaRepository<User, Long>, FilterUserRepository {

    /**
     * Тут используется HQL
     *
     * @param firstname
     * @param lastname
     * @return
     */
    @Query(value = """
            select u
            from User u
            where u.firstName like %:firstname% and
                u.lastName like %:lastname%
            """)
    List<User> findAllBy(String firstname, String lastname);

    /**
     * Тут используется native SQL.
     * Прибегать к нативным запросам стоит только в том случае, когда не возможно сделать
     * что-либо через HQL
     *
     * @param username
     * @return
     */
    @Query(value = """
            select u.*
            from users u
            where u.username = :username
            """,
            nativeQuery = true)
    List<User> findAllByUsername(String username);

    Optional<User> findFirstByOrderByIdDesc();

    /**
     * Sort - это объект из Spring Data, который используется для задания сортировки результатов запросов к базе данных.
     * Он предоставляет удобный способ управления порядком, в котором данные будут возвращаться из базы данных.
     * Sort может использоваться совместно с запросами Spring Data JPA для определения порядка сортировки результатов.
     * <p>
     * Основные элементы Sort включают в себя:
     * <p>
     * Свойство (Property): Это поле (или свойство) сущности, по которому будет выполняться сортировка.
     * <p>
     * Направление сортировки (Direction): Это определяет порядок сортировки для свойства. Направление может быть
     * восходящим (ASC) или нисходящим (DESC).
     *
     * @param birthday
     * @param sort
     * @return
     * @see org.example.spring.database.repository.UserRepositoryTest#checkSort()
     * @see org.example.spring.database.repository.UserRepositoryTest#checkSortDefault()
     */
    List<User> findFirst3ByBirthDate(LocalDate birthday, Sort sort);

    /**
     * Pageable - это интерфейс в Spring Data, который предоставляет абстракцию для запросов, связанных с постраничным
     * выводом данных из базы данных. Он позволяет определить параметры для запроса, такие как номер страницы, размер
     * страницы и порядок сортировки. Pageable используется для разделения результатов запроса на страницы и управления ими.
     * <p>
     * PageRequest - это одна из реализаций интерфейса Pageable в Spring Data. Он предоставляет удобный способ создания
     * объекта Pageable с указанием номера страницы, размера страницы и сортировки.
     * <p>
     * Pageable и PageRequest очень полезны для работы с большими объемами данных, когда необходимо выполнять
     * постраничный вывод результатов запросов. Они позволяют разбить результаты на страницы и получать только
     * необходимую часть данных, что может повысить производительность и улучшить опыт пользователя.
     * <p>
     * Page - это объект в Spring Data, предназначенный для хранения и предоставления постраничных результатов запросов
     * к базе данных. Он содержит список элементов данных, метаинформацию о странице (такую как общее количество
     * элементов и количество страниц) и информацию о сортировке. Page используется для управления и представления
     * отдельной страницы данных.
     * <p>
     * Основные элементы Page включают в себя:
     * <p>
     * Контент (Content): Это список элементов данных, представляющих текущую страницу результатов.
     * <p>
     * Номер страницы (Page Number): Это номер текущей страницы. Нумерация страниц начинается с 0.
     * <p>
     * Размер страницы (Page Size): Это количество элементов данных, которые отображаются на одной странице.
     * <p>
     * Общее количество элементов (Total Elements): Это общее количество элементов данных, доступных в результате запроса.
     * <p>
     * Общее количество страниц (Total Pages): Это общее количество страниц, на которые можно разделить результаты
     * запроса в соответствии с размером страницы.
     * <p>
     * Сортировка (Sorting): Это информация о сортировке результатов, если она была задана.
     *
     * @param pageable
     * @return
     * @see org.example.spring.database.repository.UserRepositoryTest#checkSortUsingPageable()
     */
    @EntityGraph(attributePaths = {"company"})
    @Query(
            value = """
                    select u
                    from User u
                    """,
            countQuery = """
                    select count(distinct u.firstName)
                    from User u
                    """)
    Page<User> findAllBy(Pageable pageable);

    /**
     * Аннотация @Modifying является частью Spring Data JPA и используется вместе с аннотацией @Query для обозначения
     * метода, который выполняет модифицирующий (изменяющий) запрос к базе данных. Модифицирующие запросы включают в
     * себя операции обновления (UPDATE), удаления (DELETE) и вставки (INSERT) данных в базу данных.
     * <p>
     * Когда вы объявляете метод в интерфейсе репозитория с аннотациями @Query и @Modifying, Spring Data JPA ожидает,
     * что этот метод будет выполнять модифицирующий запрос, и он будет вызван внутри транзакции.
     * <p>
     * Важные моменты относительно использования @Modifying:
     * <p>
     * Транзакция: Метод, помеченный @Modifying, будет выполняться внутри транзакции. Это означает, что он будет
     * оборачиваться в транзакцию, и любые изменения данных будут зафиксированы только после успешного завершения транзакции.
     * <p>
     * Возвращаемое значение: Метод должен возвращать int или void. Возвращаемое значение int указывает на количество
     * измененных записей в базе данных.
     * <p>
     * Осторожность: При использовании @Modifying убедитесь, что ваш запрос правильно обновляет, удаляет или вставляет
     * данные, и проверьте его на безопасность, чтобы избежать ошибок или непредвиденных изменений в данных.
     * <p>
     * Совместимость с конкретным JPA-поставщиком: Помните, что различные JPA-поставщики могут иметь свои собственные
     * особенности и требования к выполнению модифицирующих запросов. Убедитесь, что ваш запрос совместим с используемым
     * JPA-поставщиком (например, Hibernate, EclipseLink и т. д.).
     * <p></p>
     * Описание параметров @Modifying:
     * <p>
     * clearAutomatically (по умолчанию: false): Этот параметр определяет, будет ли автоматически сбрасываться кеш
     * (кэшированные объекты) EntityManager после выполнения модифицирующего запроса. Если значение установлено в true,
     * то EntityManager будет очищен после выполнения запроса. Это может быть полезным, если важно убедиться, что
     * кэшированные данные обновляются после модификации данных в базе.
     * <p>
     * flushAutomatically (по умолчанию: true): Этот параметр определяет, будет ли автоматически сбрасываться
     * EntityManager в базу данных после выполнения модифицирующего запроса. Если значение установлено в true, то
     * EntityManager будет автоматически сброшен (flushed) в базу данных после выполнения запроса. Это гарантирует,
     * что все изменения данных будут сразу же отправлены в базу данных.
     * <p>
     * batchSize (по умолчанию: 0): Этот параметр позволяет настроить размер пакета (batch size) для выполнения
     * модифицирующих операций. Если значение установлено больше 0, то операции будут выполнены пакетами указанного
     * размера. Это может быть полезно для оптимизации производительности при выполнении большого количества
     * модифицирующих операций.
     *
     * @param role
     * @param ids
     * @return
     */
    @Modifying(
            clearAutomatically = true,
            flushAutomatically = true
    )
    @Query(value = """
            update User u
            set u.role = :role
            where u.id in (:ids)
            """)
    int updateRole(Role role, Long... ids);

    /**
     * Projection (проекция) - это механизм в Spring Data JPA, который позволяет выбирать только определенные
     * атрибуты или свойства сущностей из базы данных, вместо загрузки всей сущности целиком. Проекции полезны,
     * когда вы хотите получить только часть данных из сущности, что может повысить производительность и снизить
     * нагрузку на базу данных.
     * <p>
     * В Spring Data JPA проекции могут быть реализованы несколькими способами:
     * <p>
     * Использование интерфейсов:
     * Вы можете определить интерфейс, который содержит методы-геттеры для выбранных атрибутов сущности.
     * Spring Data JPA будет автоматически создавать реализацию этого интерфейса и выполнить соответствующий SQL-запрос,
     * чтобы извлечь только указанные атрибуты из базы данных.
     * <p>
     * Использование DTO (Data Transfer Object):
     * Вы можете создать отдельный класс (DTO), который содержит только необходимые атрибуты и свойства, а затем
     * использовать конструкторы или библиотеки маппинга (например, ModelMapper) для преобразования результатов
     * запроса в объекты DTO.
     * <p>
     * Использование конструкторов сущностей:
     * Если в ваших сущностях имеются конструкторы, которые принимают только необходимые атрибуты, вы можете
     * использовать их для создания объектов сущностей с выбранными атрибутами.
     * <p>
     * Проекции позволяют оптимизировать запросы к базе данных и уменьшить объем передаваемых данных, что может
     * быть особенно полезно при работе с большими объемами данных или при использовании REST API для передачи данных
     * на клиентскую сторону.
     * <p>
     * Однако стоит помнить, что проекции могут уменьшить уровень абстракции и типобезопасность, которые предоставляет
     * JPA, поэтому их следует использовать там, где это действительно необходимо для оптимизации производительности.
     *
     * @param companyId
     * @return
     * @see PersonalInfo
     */
//    List<PersonalInfo> findAllByCompanyId(Integer companyId);

    /**
     * Дженерик проекция
     *
     * @param companyId
     * @param clazz
     * @param <T>
     * @return
     */
    <T> List<T> findAllByCompanyId(Integer companyId, Class<T> clazz);

    @Query(value = """
            select
            firstname firstName,
            lastname lastName,
            birth_date birthDate
            from users
            where company_id = :companyId
            """ ,nativeQuery = true)
    List<PersonalInfoInterface> findAllByCompanyId(Integer companyId);
}
