package org.example.spring.database.repository;

import org.example.spring.database.entity.User;
import org.example.spring.database.entity.enums.Role;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

/**
 * {@code @Repository} - это аннотация в Spring Framework, которая используется для пометки класса как репозитория (хранилища)
 * данных. Репозитории являются частью архитектуры доступа к данным (Data Access Layer) и предоставляют способ
 * взаимодействия с базой данных или другими источниками данных. Классы, помеченные @Repository, обычно используются
 * для выполнения операций чтения и записи данных в базе данных.
 * <p>
 * Основные характеристики и использование аннотации @Repository:
 * <p>
 * Обнаружение бинов: Классы, помеченные аннотацией @Repository, автоматически обнаруживаются Spring и регистрируются
 * как Spring бины в контексте приложения. Это позволяет использовать их для взаимодействия с данными, выполняя
 * операции базы данных.
 * <p>
 * Исключение обработки: Классы, помеченные @Repository, обычно используются для доступа к данным и могут автоматически
 * обрабатывать исключения, связанные с доступом к данным, и преобразовывать их в Spring исключения
 * (например, DataAccessException), что упрощает обработку ошибок доступа к данным.
 * <p>
 * Интеграция с Spring Data: @Repository часто используется в сочетании с Spring Data, что позволяет создавать
 * репозитории с помощью интерфейсов и автоматически создавать реализацию этих репозиториев Spring Data.
 */
public interface UserRepository extends JpaRepository<User, Long> {

    /**
     * Тут используется HQL
     *
     * @param firstname
     * @param lastname
     * @return
     */
    @Query(value = """
            select u
            from User u
            where u.firstName like %:firstname% and
                u.lastName like %:lastname%
            """)
    List<User> findAllBy(String firstname, String lastname);

    /**
     * Тут используется native SQL.
     * Прибегать к нативным запросам стоит только в том случае, когда не возможно сделать
     * что-либо через HQL
     *
     * @param username
     * @return
     */
    @Query(value = """
            select u.*
            from users u
            where u.username = :username
            """,
            nativeQuery = true)
    List<User> findAllByUsername(String username);

    Optional<User> findFirstByOrderByIdDesc();

    /**
     * Sort - это объект из Spring Data, который используется для задания сортировки результатов запросов к базе данных.
     * Он предоставляет удобный способ управления порядком, в котором данные будут возвращаться из базы данных.
     * Sort может использоваться совместно с запросами Spring Data JPA для определения порядка сортировки результатов.
     * <p>
     * Основные элементы Sort включают в себя:
     * <p>
     * Свойство (Property): Это поле (или свойство) сущности, по которому будет выполняться сортировка.
     * <p>
     * Направление сортировки (Direction): Это определяет порядок сортировки для свойства. Направление может быть
     * восходящим (ASC) или нисходящим (DESC).
     *
     * @param birthday
     * @param sort
     * @return
     * @see org.example.spring.database.repository.UserRepositoryTest#checkSort()
     * @see org.example.spring.database.repository.UserRepositoryTest#checkSortDefault()
     */
    List<User> findFirst3ByBirthDate(LocalDate birthday, Sort sort);

    /**
     * Pageable - это интерфейс в Spring Data, который предоставляет абстракцию для запросов, связанных с постраничным
     * выводом данных из базы данных. Он позволяет определить параметры для запроса, такие как номер страницы, размер
     * страницы и порядок сортировки. Pageable используется для разделения результатов запроса на страницы и управления ими.
     * <p>
     * PageRequest - это одна из реализаций интерфейса Pageable в Spring Data. Он предоставляет удобный способ создания
     * объекта Pageable с указанием номера страницы, размера страницы и сортировки.
     * <p>
     * Pageable и PageRequest очень полезны для работы с большими объемами данных, когда необходимо выполнять
     * постраничный вывод результатов запросов. Они позволяют разбить результаты на страницы и получать только
     * необходимую часть данных, что может повысить производительность и улучшить опыт пользователя.
     * <p>
     *
     * @param pageable
     * @return
     * @see org.example.spring.database.repository.UserRepositoryTest#checkSortUsingPageable()
     */
    List<User> findAllBy(Pageable pageable);

    /**
     * Аннотация @Modifying является частью Spring Data JPA и используется вместе с аннотацией @Query для обозначения
     * метода, который выполняет модифицирующий (изменяющий) запрос к базе данных. Модифицирующие запросы включают в
     * себя операции обновления (UPDATE), удаления (DELETE) и вставки (INSERT) данных в базу данных.
     * <p>
     * Когда вы объявляете метод в интерфейсе репозитория с аннотациями @Query и @Modifying, Spring Data JPA ожидает,
     * что этот метод будет выполнять модифицирующий запрос, и он будет вызван внутри транзакции.
     * <p>
     * Важные моменты относительно использования @Modifying:
     * <p>
     * Транзакция: Метод, помеченный @Modifying, будет выполняться внутри транзакции. Это означает, что он будет
     * оборачиваться в транзакцию, и любые изменения данных будут зафиксированы только после успешного завершения транзакции.
     * <p>
     * Возвращаемое значение: Метод должен возвращать int или void. Возвращаемое значение int указывает на количество
     * измененных записей в базе данных.
     * <p>
     * Осторожность: При использовании @Modifying убедитесь, что ваш запрос правильно обновляет, удаляет или вставляет
     * данные, и проверьте его на безопасность, чтобы избежать ошибок или непредвиденных изменений в данных.
     * <p>
     * Совместимость с конкретным JPA-поставщиком: Помните, что различные JPA-поставщики могут иметь свои собственные
     * особенности и требования к выполнению модифицирующих запросов. Убедитесь, что ваш запрос совместим с используемым
     * JPA-поставщиком (например, Hibernate, EclipseLink и т. д.).
     * <p></p>
     * Описание параметров @Modifying:
     * <p>
     * clearAutomatically (по умолчанию: false): Этот параметр определяет, будет ли автоматически сбрасываться кеш
     * (кэшированные объекты) EntityManager после выполнения модифицирующего запроса. Если значение установлено в true,
     * то EntityManager будет очищен после выполнения запроса. Это может быть полезным, если важно убедиться, что
     * кэшированные данные обновляются после модификации данных в базе.
     * <p>
     * flushAutomatically (по умолчанию: true): Этот параметр определяет, будет ли автоматически сбрасываться
     * EntityManager в базу данных после выполнения модифицирующего запроса. Если значение установлено в true, то
     * EntityManager будет автоматически сброшен (flushed) в базу данных после выполнения запроса. Это гарантирует,
     * что все изменения данных будут сразу же отправлены в базу данных.
     * <p>
     * batchSize (по умолчанию: 0): Этот параметр позволяет настроить размер пакета (batch size) для выполнения
     * модифицирующих операций. Если значение установлено больше 0, то операции будут выполнены пакетами указанного
     * размера. Это может быть полезно для оптимизации производительности при выполнении большого количества
     * модифицирующих операций.
     *
     * @param role
     * @param ids
     * @return
     */
    @Modifying(
            clearAutomatically = true,
            flushAutomatically = true
    )
    @Query(value = """
            update User u
            set u.role = :role
            where u.id in (:ids)
            """)
    int updateRole(Role role, Long... ids);
}
